I"#‚<h2 id="ä¸‰æ–¹åº“æºç åˆ†æokhttp">ä¸‰æ–¹åº“æºç åˆ†æï¼ˆOkHttpï¼‰</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>ä¸»æµä¸‰æ–¹åº“ï¼š
ç½‘ç»œï¼š
1ã€OkHttp
2ã€Retrofit
å›¾ç‰‡ï¼š
3ã€Glide
æ•°æ®åº“ï¼š
4ã€GreenDao
å“åº”å¼ç¼–ç¨‹ï¼š
5ã€RxJava
å†…å­˜æ³„éœ²ï¼š
6ã€LeakCanary
ä¾èµ–æ³¨å…¥ï¼š
7ã€ButterKnife
8ã€Dagger2
äº‹ä»¶æ€»çº¿ï¼š
9ã€EventBus
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" alt="" /></p>

<ul>
  <li>OkHttpè¯·æ±‚æµç¨‹</li>
  <li>ç½‘ç»œè¯·æ±‚ç¼“å­˜å¤„ç†</li>
  <li>è¿æ¥æ± </li>
  <li>é¦–å…ˆï¼Œè¡¥å……ä¸€ç‚¹ç½‘ç»œçŸ¥è¯†ï¼š</li>
</ul>

<p>ä¸€äº›å¸¸ç”¨çš„çŠ¶æ€ç </p>

<ul>
  <li>100~199ï¼šæŒ‡ç¤ºä¿¡æ¯ï¼Œè¡¨ç¤ºè¯·æ±‚å·²æ¥æ”¶ï¼Œç»§ç»­å¤„ç†</li>
  <li>200~299ï¼šè¯·æ±‚æˆåŠŸï¼Œè¡¨ç¤ºè¯·æ±‚å·²è¢«æˆåŠŸæ¥æ”¶ã€ç†è§£</li>
  <li>300~399ï¼šé‡å®šå‘ï¼Œè¦å®Œæˆè¯·æ±‚å¿…é¡»è¿›è¡Œæ›´è¿›ä¸€æ­¥çš„æ“ä½œ</li>
  <li>400~499ï¼šå®¢æˆ·ç«¯é”™è¯¯ï¼Œè¯·æ±‚æœ‰è¯­æ³•é”™è¯¯æˆ–è¯·æ±‚æ— æ³•å®ç°</li>
  <li>500~599ï¼šæœåŠ¡å™¨ç«¯é”™è¯¯ï¼ŒæœåŠ¡å™¨æœªèƒ½å®ç°åˆæ³•çš„è¯·æ±‚</li>
</ul>

<h3 id="ä¸€okhttpè¯·æ±‚æµç¨‹">ä¸€ã€OKHttpè¯·æ±‚æµç¨‹</h3>
<p><img src="https://upload-images.jianshu.io/upload_images/1916953-fc6439af2bfefddc.jpg?imageMogr2/auto-orient/" alt="" /></p>

<p>å¦‚ä¸‹ä¸ºä½¿ç”¨OkHttpè¿›è¡ŒGetè¯·æ±‚çš„æ­¥éª¤ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>//1.æ–°å»ºOKHttpClientå®¢æˆ·ç«¯
OkHttpClient client = new OkHttpClient();
//æ–°å»ºä¸€ä¸ªRequestå¯¹è±¡
Request request = new Request.Builder()
        .url(url)
        .build();
//2.Responseä¸ºOKHttpä¸­çš„å“åº”
Response response = client.newCall(request).execute();
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="1æ–°å»ºokhttpclientå®¢æˆ·ç«¯">1.æ–°å»ºOKHttpClientå®¢æˆ·ç«¯</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre>OkHttpClient client = new OkHttpClient();

public OkHttpClient() {
    this(new Builder());
}

OkHttpClient(Builder builder) {
    ....
} å¯ä»¥çœ‹åˆ°ï¼ŒOkHttpClientä½¿ç”¨äº†å»ºé€ è€…æ¨¡å¼ï¼ŒBuilderé‡Œé¢çš„å¯é…ç½®å‚æ•°å¦‚ä¸‹ï¼š

public static final class Builder {
    Dispatcher dispatcher;// åˆ†å‘å™¨
    @Nullable Proxy proxy;
    List&lt;Protocol&gt; protocols;
    List&lt;ConnectionSpec&gt; connectionSpecs;// ä¼ è¾“å±‚ç‰ˆæœ¬å’Œè¿æ¥åè®®
    final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();// æ‹¦æˆªå™¨
    final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();
    EventListener.Factory eventListenerFactory;
    ProxySelector proxySelector;
    CookieJar cookieJar;
    @Nullable Cache cache;
    @Nullable InternalCache internalCache;// å†…éƒ¨ç¼“å­˜
    SocketFactory socketFactory;
    @Nullable SSLSocketFactory sslSocketFactory;// å®‰å…¨å¥—æ¥å±‚socket å·¥å‚ï¼Œç”¨äºHTTPS
    @Nullable CertificateChainCleaner certificateChainCleaner;// éªŒè¯ç¡®è®¤å“åº”è¯ä¹¦ é€‚ç”¨ HTTPS è¯·æ±‚è¿æ¥çš„ä¸»æœºåã€‚
    HostnameVerifier hostnameVerifier;// éªŒè¯ç¡®è®¤å“åº”è¯ä¹¦ é€‚ç”¨ HTTPS è¯·æ±‚è¿æ¥çš„ä¸»æœºåã€‚  
    CertificatePinner certificatePinner;// è¯ä¹¦é”å®šï¼Œä½¿ç”¨CertificatePinneræ¥çº¦æŸå“ªäº›è®¤è¯æœºæ„è¢«ä¿¡ä»»ã€‚
    Authenticator proxyAuthenticator;// ä»£ç†èº«ä»½éªŒè¯
    Authenticator authenticator;// èº«ä»½éªŒè¯
    ConnectionPool connectionPool;// è¿æ¥æ± 
    Dns dns;
    boolean followSslRedirects; // å®‰å…¨å¥—æ¥å±‚é‡å®šå‘
    boolean followRedirects;// æœ¬åœ°é‡å®šå‘
    boolean retryOnConnectionFailure;// é‡è¯•è¿æ¥å¤±è´¥
    int callTimeout;
    int connectTimeout;
    int readTimeout;
    int writeTimeout;
    int pingInterval;

    // è¿™é‡Œæ˜¯é»˜è®¤é…ç½®çš„æ„å»ºå‚æ•°
    public Builder() {
        dispatcher = new Dispatcher();
        protocols = DEFAULT_PROTOCOLS;
        connectionSpecs = DEFAULT_CONNECTION_SPECS;
        ...
    }

    // è¿™é‡Œä¼ å…¥è‡ªå·±é…ç½®çš„æ„å»ºå‚æ•°
    Builder(OkHttpClient okHttpClient) {
        this.dispatcher = okHttpClient.dispatcher;
        this.proxy = okHttpClient.proxy;
        this.protocols = okHttpClient.protocols;
        this.connectionSpecs = okHttpClient.connectionSpecs;
        this.interceptors.addAll(okHttpClient.interceptors);
        this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
        ...
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>#### 	
2.åŒæ­¥è¯·æ±‚æµç¨‹</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
</pre></td><td class="rouge-code"><pre>Response response = client.newCall(request).execute();

/**
* Prepares the {@code request} to be executed at   some point in the future.
*/
@Override public Call newCall(Request request) {
    return RealCall.newRealCall(this, request, false /* for web socket */);
}

// RealCallä¸ºçœŸæ­£çš„è¯·æ±‚æ‰§è¡Œè€…
static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    // Safely publish the Call instance to the EventListener.
    RealCall call = new RealCall(client, originalRequest, forWebSocket);
    call.eventListener = client.eventListenerFactory().create(call);
    return call;
}


@Override public Response execute() throws IOException {
    synchronized (this) {
        // æ¯ä¸ªCallåªèƒ½æ‰§è¡Œä¸€æ¬¡
        if (executed) throw new IllegalStateException("Already Executed");
        executed = true;
    }
    captureCallStackTrace();
    timeout.enter();
    eventListener.callStart(this);
    try {
        // é€šçŸ¥dispatcherå·²ç»è¿›å…¥æ‰§è¡ŒçŠ¶æ€
        client.dispatcher().executed(this);
        // é€šè¿‡ä¸€ç³»åˆ—çš„æ‹¦æˆªå™¨è¯·æ±‚å¤„ç†å’Œå“åº”å¤„ç†å¾—åˆ°æœ€ç»ˆçš„è¿”å›ç»“æœ
        Response result = getResponseWithInterceptorChain();
        if (result == null) throw new IOException("Canceled");
        return result;
    } catch (IOException e) {
        e = timeoutExit(e);
        eventListener.callFailed(this, e);
        throw e;
    } finally {
        // é€šçŸ¥ dispatcher è‡ªå·±å·²ç»æ‰§è¡Œå®Œæ¯•
        client.dispatcher().finished(this);
    }
}

Response getResponseWithInterceptorChain() throws IOException {
    // Build a full stack of interceptors.
    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();
    // åœ¨é…ç½® OkHttpClient æ—¶è®¾ç½®çš„ interceptorsï¼›
    interceptors.addAll(client.interceptors());
    // è´Ÿè´£å¤±è´¥é‡è¯•ä»¥åŠé‡å®šå‘
    interceptors.add(retryAndFollowUpInterceptor);
    // è¯·æ±‚æ—¶ï¼Œå¯¹å¿…è¦çš„Headerè¿›è¡Œä¸€äº›æ·»åŠ ï¼Œæ¥æ”¶å“åº”æ—¶ï¼Œç§»é™¤å¿…è¦çš„Header
    interceptors.add(new BridgeInterceptor(client.cookieJar()));
    // è´Ÿè´£è¯»å–ç¼“å­˜ç›´æ¥è¿”å›ã€æ›´æ–°ç¼“å­˜
    interceptors.add(new CacheInterceptor(client.internalCache()));
    // è´Ÿè´£å’ŒæœåŠ¡å™¨å»ºç«‹è¿æ¥
    interceptors.add(new ConnectInterceptor(client));
    if (!forWebSocket) {
        // é…ç½® OkHttpClient æ—¶è®¾ç½®çš„ networkInterceptors
        interceptors.addAll(client.networkInterceptors());
    }
    // è´Ÿè´£å‘æœåŠ¡å™¨å‘é€è¯·æ±‚æ•°æ®ã€ä»æœåŠ¡å™¨è¯»å–å“åº”æ•°æ®
    interceptors.add(new CallServerInterceptor(forWebSocket));

    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
        originalRequest, this, eventListener, client.connectTimeoutMillis(),
        client.readTimeoutMillis(), client.writeTimeoutMillis());

    // ä½¿ç”¨è´£ä»»é“¾æ¨¡å¼å¼€å¯é“¾å¼è°ƒç”¨
    return chain.proceed(originalRequest);
}

// StreamAllocation å¯¹è±¡ï¼Œå®ƒç›¸å½“äºä¸€ä¸ªç®¡ç†ç±»ï¼Œç»´æŠ¤äº†æœåŠ¡å™¨è¿æ¥ã€å¹¶å‘æµ
// å’Œè¯·æ±‚ä¹‹é—´çš„å…³ç³»ï¼Œè¯¥ç±»è¿˜ä¼šåˆå§‹åŒ–ä¸€ä¸ª Socket è¿æ¥å¯¹è±¡ï¼Œè·å–è¾“å…¥/è¾“å‡ºæµå¯¹è±¡ã€‚
public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
  RealConnection connection) throws IOException {
    ...

    // Call the next interceptor in the chain.
    // å®ä¾‹åŒ–ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨å¯¹åº”çš„RealIterceptorChainå¯¹è±¡
    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
        writeTimeout);
    // å¾—åˆ°å½“å‰çš„æ‹¦æˆªå™¨
    Interceptor interceptor = interceptors.get(index);
    // è°ƒç”¨å½“å‰æ‹¦æˆªå™¨çš„intercept()æ–¹æ³•ï¼Œå¹¶å°†ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨çš„RealIterceptorChainå¯¹è±¡ä¼ é€’ä¸‹å»,æœ€åå¾—åˆ°å“åº”
    Response response = interceptor.intercept(next);

    ...

    return response;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="3å¼‚æ­¥è¯·æ±‚çš„æµç¨‹">3.å¼‚æ­¥è¯·æ±‚çš„æµç¨‹</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre>Request request = new Request.Builder()
    .url("http://publicobject.com/helloworld.txt")
    .build();

client.newCall(request).enqueue(new Callback() {
    @Override 
    public void onFailure(Call call, IOException e) {
      e.printStackTrace();
    }

    @Override 
    public void onResponse(Call call, Response response) throws IOException {
        ...
    }

void enqueue(AsyncCall call) {
    synchronized (this) {
        readyAsyncCalls.add(call);
    }
    promoteAndExecute();
}

// æ­£åœ¨å‡†å¤‡ä¸­çš„å¼‚æ­¥è¯·æ±‚é˜Ÿåˆ—
private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();

// è¿è¡Œä¸­çš„å¼‚æ­¥è¯·æ±‚
private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();

// åŒæ­¥è¯·æ±‚
private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();

// Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs
// them on the executor service. Must not be called with synchronization because executing calls
// can call into user code.
private boolean promoteAndExecute() {
    assert (!Thread.holdsLock(this));

    List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();
    boolean isRunning;
    synchronized (this) {
      for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
        AsyncCall asyncCall = i.next();

        // å¦‚æœå…¶ä¸­çš„runningAsynCallsä¸æ»¡ï¼Œä¸”callå ç”¨çš„hostå°äºæœ€å¤§æ•°é‡ï¼Œåˆ™å°†callåŠ å…¥åˆ°runningAsyncCallsä¸­æ‰§è¡Œï¼Œ
        // åŒæ—¶åˆ©ç”¨çº¿ç¨‹æ± æ‰§è¡Œcallï¼›å¦è€…å°†callåŠ å…¥åˆ°readyAsyncCallsä¸­ã€‚
        if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity.
        if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity.

        i.remove();
        executableCalls.add(asyncCall);
        runningAsyncCalls.add(asyncCall);
      }
      isRunning = runningCallsCount() &gt; 0;
    }

    for (int i = 0, size = executableCalls.size(); i &lt; size; i++) {
      AsyncCall asyncCall = executableCalls.get(i);
      asyncCall.executeOn(executorService());
    }

    return isRunning;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="4asyncallçš„ä»£ç ">4.AsynCallçš„ä»£ç ã€‚</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="rouge-code"><pre>final class AsyncCall extends NamedRunnable {
    private final Callback responseCallback;

    AsyncCall(Callback responseCallback) {
      super("OkHttp %s", redactedUrl());
      this.responseCallback = responseCallback;
    }

    String host() {
      return originalRequest.url().host();
    }

    Request request() {
      return originalRequest;
    }

    RealCall get() {
      return RealCall.this;
    }

    /**
     * Attempt to enqueue this async call on {@code    executorService}. This will attempt to clean up
     * if the executor has been shut down by reporting    the call as failed.
     */
    void executeOn(ExecutorService executorService) {
      assert (!Thread.holdsLock(client.dispatcher()));
      boolean success = false;
      try {
        executorService.execute(this);
        success = true;
      } catch (RejectedExecutionException e) {
        InterruptedIOException ioException = new InterruptedIOException("executor rejected");
        ioException.initCause(e);
        eventListener.callFailed(RealCall.this, ioException);
        responseCallback.onFailure(RealCall.this, ioException);
      } finally {
        if (!success) {
          client.dispatcher().finished(this); // This call is no longer running!
        }
      }
    }

    @Override protected void execute() {
      boolean signalledCallback = false;
      timeout.enter();
      try {
        // è·ŸåŒæ­¥æ‰§è¡Œä¸€æ ·ï¼Œæœ€åéƒ½ä¼šè°ƒç”¨åˆ°è¿™é‡Œ
        Response response = getResponseWithInterceptorChain();
        if (retryAndFollowUpInterceptor.isCanceled()) {
          signalledCallback = true;
          responseCallback.onFailure(RealCall.this, new   IOException("Canceled"));
        } else {
          signalledCallback = true;
          responseCallback.onResponse(RealCall.this,   response);
        }
      } catch (IOException e) {
        e = timeoutExit(e);
        if (signalledCallback) {
          // Do not signal the callback twice!
          Platform.get().log(INFO, "Callback failure   for " + toLoggableString(), e);
        } else {
          eventListener.callFailed(RealCall.this, e);
          responseCallback.onFailure(RealCall.this, e);
        }
      } finally {
        client.dispatcher().finished(this);
      }
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ä»ä¸Šé¢çš„æºç å¯ä»¥çŸ¥é“ï¼Œæ‹¦æˆªé“¾çš„å¤„ç†OKHttpå¸®æˆ‘ä»¬é»˜è®¤åšäº†äº”æ­¥æ‹¦æˆªå¤„ç†ï¼Œå…¶ä¸­RetryAndFollowUpInterceptorã€BridgeInterceptorã€CallServerInterceptorå†…éƒ¨çš„æºç å¾ˆç®€æ´æ˜“æ‡‚ï¼Œæ­¤å¤„ä¸å†å¤šè¯´ï¼Œä¸‹é¢å°†å¯¹OKHttpæœ€ä¸ºæ ¸å¿ƒçš„ä¸¤éƒ¨åˆ†ï¼šç¼“å­˜å¤„ç†å’Œè¿æ¥å¤„ç†ï¼ˆè¿æ¥æ± ï¼‰è¿›è¡Œè®²è§£</p>

<h3 id="äºŒç½‘ç»œè¯·æ±‚ç¼“å­˜å¤„ç†ä¹‹cacheinterceptor">äºŒã€ç½‘ç»œè¯·æ±‚ç¼“å­˜å¤„ç†ä¹‹CacheInterceptor</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre>@Override public Response intercept(Chain chain) throws IOException {
    // æ ¹æ®requestå¾—åˆ°cacheä¸­ç¼“å­˜çš„response
    Response cacheCandidate = cache != null
        ? cache.get(chain.request())
        : null;

long now = System.currentTimeMillis();

// requeståˆ¤æ–­ç¼“å­˜çš„ç­–ç•¥ï¼Œæ˜¯å¦è¦ä½¿ç”¨äº†ç½‘ç»œï¼Œç¼“å­˜æˆ–ä¸¤è€…éƒ½ä½¿ç”¨
CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(),     cacheCandidate).get();
Request networkRequest = strategy.networkRequest;
Response cacheResponse = strategy.cacheResponse;

if (cache != null) {
  cache.trackResponse(strategy);
}

if (cacheCandidate != null &amp;&amp; cacheResponse == null) {
  closeQuietly(cacheCandidate.body()); // The cache   candidate wasn't applicable. Close it.
}

// If we're forbidden from using the network and the cache is insufficient, fail.
if (networkRequest == null &amp;&amp; cacheResponse == null) {
  return new Response.Builder()
      .request(chain.request())
      .protocol(Protocol.HTTP_1_1)
      .code(504)
      .message("Unsatisfiable Request (only-if-cached)")
      .body(Util.EMPTY_RESPONSE)
      .sentRequestAtMillis(-1L)
      .receivedResponseAtMillis(System.currentTimeMillis())
      .build();
}

// If we don't need the network, we're done.
if (networkRequest == null) {
  return cacheResponse.newBuilder()
      .cacheResponse(stripBody(cacheResponse))
      .build();
}

Response networkResponse = null;
try {
    // è°ƒç”¨ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨ï¼Œå†³å®šä»ç½‘ç»œä¸Šæ¥å¾—åˆ°response
    networkResponse = chain.proceed(networkRequest);
} finally {
    // If we're crashing on I/O or otherwise,   don't leak the cache body.
    if (networkResponse == null &amp;&amp; cacheCandidate != null) {
      closeQuietly(cacheCandidate.body());
    }
}

// If we have a cache response too, then we're doing a conditional get.
// å¦‚æœæœ¬åœ°å·²ç»å­˜åœ¨cacheResponseï¼Œé‚£ä¹ˆè®©å®ƒå’Œç½‘ç»œå¾—åˆ°çš„networkResponseåšæ¯”è¾ƒï¼Œå†³å®šæ˜¯å¦æ¥æ›´æ–°ç¼“å­˜çš„cacheResponse
if (cacheResponse != null) {
    if (networkResponse.code() == HTTP_NOT_MODIFIED)   {
      Response response = cacheResponse.newBuilder()
              .headers(combine(cacheResponse.headers(), networkResponse.headers()))
              .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
              .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
              .cacheResponse(stripBody(cacheResponse))
              .networkResponse(stripBody(networkResponse))
          .build();
      networkResponse.body().close();

      // Update the cache after combining headers but before stripping the
      // Content-Encoding header (as performed by initContentStream()).
      cache.trackConditionalCacheHit();
      cache.update(cacheResponse, response);
      return response;
    } else {
      closeQuietly(cacheResponse.body());
    }
}

Response response = networkResponse.newBuilder()
    .cacheResponse(stripBody(cacheResponse))
    .networkResponse(stripBody(networkResponse))
    .build();

if (cache != null) {
  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response,   networkRequest)) {
    // Offer this request to the cache.
    // ç¼“å­˜æœªç»ç¼“å­˜è¿‡çš„response
    CacheRequest cacheRequest = cache.put(response);
    return cacheWritingResponse(cacheRequest, response);
  }

  if (HttpMethod.invalidatesCache(networkRequest.method())) {
    try {
      cache.remove(networkRequest);
    } catch (IOException ignored) {
      // The cache cannot be written.
    }
  }
}

return response;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ç¼“å­˜æ‹¦æˆªå™¨ä¼šæ ¹æ®è¯·æ±‚çš„ä¿¡æ¯å’Œç¼“å­˜çš„å“åº”çš„ä¿¡æ¯æ¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¼“å­˜å¯ç”¨ï¼Œå¦‚æœæœ‰å¯ä»¥ä½¿ç”¨çš„ç¼“å­˜ï¼Œé‚£ä¹ˆå°±è¿”å›è¯¥ç¼“å­˜ç»™ç”¨æˆ·ï¼Œå¦åˆ™å°±ç»§ç»­ä½¿ç”¨è´£ä»»é“¾æ¨¡å¼æ¥ä»æœåŠ¡å™¨ä¸­è·å–å“åº”ã€‚å½“è·å–åˆ°å“åº”çš„æ—¶å€™ï¼Œåˆä¼šæŠŠå“åº”ç¼“å­˜åˆ°ç£ç›˜ä¸Šé¢ã€‚</p>

<h3 id="ä¸‰connectinterceptorä¹‹è¿æ¥æ± ">ä¸‰ã€ConnectInterceptorä¹‹è¿æ¥æ± </h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
</pre></td><td class="rouge-code"><pre>@Override public Response intercept(Chain chain) throws IOException {
RealInterceptorChain realChain = (RealInterceptorChain) chain;
Request request = realChain.request();
StreamAllocation streamAllocation = realChain.streamAllocation();

// We need the network to satisfy this request.     Possibly for validating a conditional GET.
boolean doExtensiveHealthChecks = !request.method().equals("GET");
// HttpCodecæ˜¯å¯¹ HTTP åè®®æ“ä½œçš„æŠ½è±¡ï¼Œæœ‰ä¸¤ä¸ªå®ç°ï¼šHttp1Codecå’ŒHttp2Codecï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº” HTTP/1.1 å’Œ HTTP/2 ç‰ˆæœ¬çš„å®ç°ã€‚åœ¨è¿™ä¸ªæ–¹æ³•çš„å†…éƒ¨å®ç°è¿æ¥æ± çš„å¤ç”¨å¤„ç†
HttpCodec httpCodec = streamAllocation.newStream(client, chain,     doExtensiveHealthChecks);
RealConnection connection = streamAllocation.connection();

return realChain.proceed(request, streamAllocation, httpCodec, connection);
}



// Returns a connection to host a new stream. This // prefers the existing connection if it exists,
// then the pool, finally building a new connection.
// è°ƒç”¨ streamAllocation çš„ newStream() æ–¹æ³•çš„æ—¶å€™ï¼Œæœ€ç»ˆä¼šç»è¿‡ä¸€ç³»åˆ—
// çš„åˆ¤æ–­åˆ°è¾¾ StreamAllocation ä¸­çš„ findConnection() æ–¹æ³•
private RealConnection findConnection(int   connectTimeout, int readTimeout, int writeTimeout,
    int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
      ...

  // Attempt to use an already-allocated connection. We need to be careful here because our
  // already-allocated connection may have been restricted from creating new streams.
  // å°è¯•ä½¿ç”¨å·²åˆ†é…çš„è¿æ¥ï¼Œå·²ç»åˆ†é…çš„è¿æ¥å¯èƒ½å·²ç»è¢«é™åˆ¶åˆ›å»ºæ–°çš„æµ
  releasedConnection = this.connection;
  // é‡Šæ”¾å½“å‰è¿æ¥çš„èµ„æºï¼Œå¦‚æœè¯¥è¿æ¥å·²ç»è¢«é™åˆ¶åˆ›å»ºæ–°çš„æµï¼Œå°±è¿”å›ä¸€ä¸ªSocketä»¥å…³é—­è¿æ¥
  toClose = releaseIfNoNewStreams();
  if (this.connection != null) {
    // We had an already-allocated connection and it's good.
    result = this.connection;
    releasedConnection = null;
  }
  if (!reportedAcquired) {
    // If the connection was never reported acquired, don't report it as released!
    // å¦‚æœè¯¥è¿æ¥ä»æœªè¢«æ ‡è®°ä¸ºè·å¾—ï¼Œä¸è¦æ ‡è®°ä¸ºå‘å¸ƒçŠ¶æ€ï¼ŒreportedAcquired é€šè¿‡ acquire()   æ–¹æ³•ä¿®æ”¹
    releasedConnection = null;
  }

  if (result == null) {
    // Attempt to get a connection from the pool.
    // å°è¯•ä¾›è¿æ¥æ± ä¸­è·å–ä¸€ä¸ªè¿æ¥
    Internal.instance.get(connectionPool, address, this, null);
    if (connection != null) {
      foundPooledConnection = true;
      result = connection;
    } else {
      selectedRoute = route;
    }
  }
}
// å…³é—­è¿æ¥
closeQuietly(toClose);

if (releasedConnection != null) {
  eventListener.connectionReleased(call, releasedConnection);
}
if (foundPooledConnection) {
  eventListener.connectionAcquired(call, result);
}
if (result != null) {
  // If we found an already-allocated or pooled connection, we're done.
  // å¦‚æœå·²ç»ä»è¿æ¥æ± ä¸­è·å–åˆ°äº†ä¸€ä¸ªè¿æ¥ï¼Œå°±å°†å…¶è¿”å›
  return result;
}

// If we need a route selection, make one. This   is a blocking operation.
boolean newRouteSelection = false;
if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) {
  newRouteSelection = true;
  routeSelection = routeSelector.next();
}

synchronized (connectionPool) {
  if (canceled) throw new IOException("Canceled");

  if (newRouteSelection) {
    // Now that we have a set of IP addresses,   make another attempt at getting a   connection from
    // the pool. This could match due to   connection coalescing.
     // æ ¹æ®ä¸€ç³»åˆ—çš„ IPåœ°å€ä»è¿æ¥æ± ä¸­è·å–ä¸€ä¸ªé“¾æ¥
    List&lt;Route&gt; routes = routeSelection.getAll();
    for (int i = 0, size = routes.size(); i &lt; size;i++) {
      Route route = routes.get(i);
      // ä»è¿æ¥æ± ä¸­è·å–ä¸€ä¸ªè¿æ¥
      Internal.instance.get(connectionPool, address, this, route);
      if (connection != null) {
        foundPooledConnection = true;
        result = connection;
        this.route = route;
        break;
      }
    }
  }

  if (!foundPooledConnection) {
    if (selectedRoute == null) {
      selectedRoute = routeSelection.next();
    }

    // Create a connection and assign it to this allocation immediately. This makes it   possible
    // for an asynchronous cancel() to interrupt the handshake we're about to do.
    // åœ¨è¿æ¥æ± ä¸­å¦‚æœæ²¡æœ‰è¯¥è¿æ¥ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„è¿æ¥ï¼Œå¹¶å°†å…¶åˆ†é…ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨æ¡æ‰‹ä¹‹å‰è¿›è¡Œç»ˆç«¯
    route = selectedRoute;
    refusedStreamCount = 0;
    result = new RealConnection(connectionPool, selectedRoute);
    acquire(result, false);
  }
}
// If we found a pooled connection on the 2nd time around, we're done.
if (foundPooledConnection) {
// å¦‚æœæˆ‘ä»¬åœ¨ç¬¬äºŒæ¬¡çš„æ—¶å€™å‘ç°äº†ä¸€ä¸ªæ± è¿æ¥ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å°†å…¶è¿”å›
  eventListener.connectionAcquired(call, result);
  return result;
}

// Do TCP + TLS handshakes. This is a blocking     operation.
 // è¿›è¡Œ TCP å’Œ TLS æ¡æ‰‹
result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
  connectionRetryEnabled, call, eventListener);
routeDatabase().connected(result.route());

Socket socket = null;
synchronized (connectionPool) {
  reportedAcquired = true;

  // Pool the connection.
  // å°†è¯¥è¿æ¥æ”¾è¿›è¿æ¥æ± ä¸­
  Internal.instance.put(connectionPool, result);

  // If another multiplexed connection to the same   address was created concurrently, then
  // release this connection and acquire that one.
  // å¦‚æœåŒæ—¶åˆ›å»ºäº†å¦ä¸€ä¸ªåˆ°åŒä¸€åœ°å€çš„å¤šè·¯å¤ç”¨è¿æ¥ï¼Œé‡Šæ”¾è¿™ä¸ªè¿æ¥å¹¶è·å–é‚£ä¸ªè¿æ¥
  if (result.isMultiplexed()) {
    socket = Internal.instance.deduplicate(connectionPool, address, this);
    result = connection;
  }
}
closeQuietly(socket);

eventListener.connectionAcquired(call, result);
return result;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ä»ä»¥ä¸Šçš„æºç åˆ†æå¯çŸ¥ï¼š</p>

<ul>
  <li>åˆ¤æ–­å½“å‰çš„è¿æ¥æ˜¯å¦å¯ä»¥ä½¿ç”¨ï¼šæµæ˜¯å¦å·²ç»è¢«å…³é—­ï¼Œå¹¶ä¸”å·²ç»è¢«é™åˆ¶åˆ›å»ºæ–°çš„æµï¼›</li>
  <li>å¦‚æœå½“å‰çš„è¿æ¥æ— æ³•ä½¿ç”¨ï¼Œå°±ä»è¿æ¥æ± ä¸­è·å–ä¸€ä¸ªè¿æ¥ï¼›</li>
  <li>è¿æ¥æ± ä¸­ä¹Ÿæ²¡æœ‰å‘ç°å¯ç”¨çš„è¿æ¥ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„è¿æ¥ï¼Œå¹¶è¿›è¡Œæ¡æ‰‹ï¼Œç„¶åå°†å…¶æ”¾åˆ°è¿æ¥æ± ä¸­ã€‚</li>
</ul>

<p>åœ¨ä»è¿æ¥æ± ä¸­è·å–ä¸€ä¸ªè¿æ¥çš„æ—¶å€™ï¼Œä½¿ç”¨äº† Internal çš„ get() æ–¹æ³•ã€‚Internal æœ‰ä¸€ä¸ªé™æ€çš„å®ä¾‹ï¼Œä¼šåœ¨ OkHttpClient çš„é™æ€ä»£ç å¿«ä¸­è¢«åˆå§‹åŒ–ã€‚æˆ‘ä»¬ä¼šåœ¨ Internal çš„ get() ä¸­è°ƒç”¨è¿æ¥æ± çš„ get() æ–¹æ³•æ¥å¾—åˆ°ä¸€ä¸ªè¿æ¥ã€‚å¹¶ä¸”ï¼Œä»ä¸­æˆ‘ä»¬æ˜ç™½äº†è¿æ¥å¤ç”¨çš„ä¸€ä¸ªå¥½å¤„å°±æ˜¯çœå»äº†è¿›è¡Œ TCP å’Œ TLS æ¡æ‰‹çš„ä¸€ä¸ªè¿‡ç¨‹ã€‚å› ä¸ºå»ºç«‹è¿æ¥æœ¬èº«ä¹Ÿæ˜¯éœ€è¦æ¶ˆè€—ä¸€äº›æ—¶é—´çš„ï¼Œè¿æ¥è¢«å¤ç”¨ä¹‹åå¯ä»¥æå‡æˆ‘ä»¬ç½‘ç»œè®¿é—®çš„æ•ˆç‡ã€‚</p>

<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥è¯¦ç»†åˆ†æä¸‹ConnectionPoolæ˜¯å¦‚ä½•å®ç°è¿æ¥ç®¡ç†çš„ã€‚</p>

<p>OkHttp çš„ç¼“å­˜ç®¡ç†åˆ†æˆä¸¤ä¸ªæ­¥éª¤ï¼Œä¸€è¾¹å½“æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¿æ¥çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦æŠŠå®ƒæ”¾è¿›ç¼“å­˜é‡Œé¢ï¼›å¦ä¸€è¾¹ï¼Œæˆ‘ä»¬è¿˜è¦æ¥å¯¹ç¼“å­˜è¿›è¡Œæ¸…ç†ã€‚åœ¨ ConnectionPool ä¸­ï¼Œå½“æˆ‘ä»¬å‘è¿æ¥æ± ä¸­ç¼“å­˜ä¸€ä¸ªè¿æ¥çš„æ—¶å€™ï¼Œåªè¦è°ƒç”¨åŒç«¯é˜Ÿåˆ—çš„ add() æ–¹æ³•ï¼Œå°†å…¶åŠ å…¥åˆ°åŒç«¯é˜Ÿåˆ—å³å¯ï¼Œè€Œæ¸…ç†è¿æ¥ç¼“å­˜çš„æ“ä½œåˆ™äº¤ç»™çº¿ç¨‹æ± æ¥å®šæ—¶æ‰§è¡Œã€‚</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre></td><td class="rouge-code"><pre>private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();

void put(RealConnection connection) {
assert (Thread.holdsLock(this));
    if (!cleanupRunning) {
      cleanupRunning = true;
      // ä½¿ç”¨çº¿ç¨‹æ± æ‰§è¡Œæ¸…ç†ä»»åŠ¡
      executor.execute(cleanupRunnable);
    }
    // å°†æ–°å»ºçš„è¿æ¥æ’å…¥åˆ°åŒç«¯é˜Ÿåˆ—ä¸­
    connections.add(connection);
}

 private final Runnable cleanupRunnable = new Runnable() {
@Override public void run() {
    while (true) {
        // å†…éƒ¨è°ƒç”¨ cleanup() æ–¹æ³•æ¥æ¸…ç†æ— æ•ˆçš„è¿æ¥
        long waitNanos = cleanup(System.nanoTime());
        if (waitNanos == -1) return;
        if (waitNanos &gt; 0) {
          long waitMillis = waitNanos / 1000000L;
          waitNanos -= (waitMillis * 1000000L);
          synchronized (ConnectionPool.this) {
            try {
              ConnectionPool.this.wait(waitMillis, (int) waitNanos);
            } catch (InterruptedException ignored) {
            }
          }
        }
    }
};

long cleanup(long now) {
int inUseConnectionCount = 0;
int idleConnectionCount = 0;
RealConnection longestIdleConnection = null;
long longestIdleDurationNs = Long.MIN_VALUE;

// Find either a connection to evict, or the time that the next eviction is due.
synchronized (this) {
    // éå†æ‰€æœ‰çš„è¿æ¥
    for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) {
      RealConnection connection = i.next();

      // If the connection is in use, keep     searching.
      // éå†æ‰€æœ‰çš„è¿æ¥
      if (pruneAndGetAllocationCount(connection, now) &gt; 0) {
        inUseConnectionCount++;
        continue;
      }

      idleConnectionCount++;

      // If the connection is ready to be     evicted,     we're done.
      // å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ªå¯ä»¥è¢«æ¸…ç†çš„è¿æ¥ï¼Œä¼šå°è¯•å»å¯»æ‰¾é—²ç½®æ—¶é—´æœ€ä¹…çš„è¿æ¥æ¥é‡Šæ”¾
      long idleDurationNs = now - connection.idleAtNanos;
      if (idleDurationNs &gt; longestIdleDurationNs) {
        longestIdleDurationNs = idleDurationNs;
        longestIdleConnection = connection;
      }
    }

    // maxIdleConnections è¡¨ç¤ºæœ€å¤§å…è®¸çš„é—²ç½®çš„è¿æ¥çš„æ•°é‡,keepAliveDurationNsè¡¨ç¤ºè¿æ¥å…è®¸å­˜æ´»çš„æœ€é•¿çš„æ—¶é—´ã€‚
    // é»˜è®¤ç©ºé—²è¿æ¥æœ€å¤§æ•°ç›®ä¸º5ä¸ªï¼Œkeepalive æ—¶é—´æœ€é•¿ä¸º5åˆ†é’Ÿã€‚
    if (longestIdleDurationNs &gt;= this.keepAliveDurationNs
        || idleConnectionCount &gt; this.maxIdleConnections) {
      // We've found a connection to evict. Remove it from the list, then close it     below (outside
      // of the synchronized block).
      // è¯¥è¿æ¥çš„æ—¶é•¿è¶…å‡ºäº†æœ€å¤§çš„æ´»è·ƒæ—¶é•¿æˆ–è€…é—²ç½®çš„è¿æ¥æ•°é‡è¶…å‡ºäº†æœ€å¤§å…è®¸çš„èŒƒå›´ï¼Œç›´æ¥ç§»é™¤
      connections.remove(longestIdleConnection);
    } else if (idleConnectionCount &gt; 0) {
      // A connection will be ready to evict soon.
      // é—²ç½®çš„è¿æ¥çš„æ•°é‡å¤§äº0ï¼Œåœé¡¿æŒ‡å®šçš„æ—¶é—´ï¼ˆç­‰ä¼šå„¿ä¼šå°†å…¶æ¸…ç†æ‰ï¼Œç°åœ¨è¿˜ä¸æ˜¯æ—¶å€™ï¼‰
      return keepAliveDurationNs - longestIdleDurationNs;
    } else if (inUseConnectionCount &gt; 0) {
      // All connections are in use. It'll be at least the keep alive duration 'til we run again.
      // æ‰€æœ‰çš„è¿æ¥éƒ½åœ¨ä½¿ç”¨ä¸­ï¼Œ5åˆ†é’Ÿåå†æ¸…ç†
      return keepAliveDurationNs;
    } else {
      // No connections, idle or in use.
       // æ²¡æœ‰è¿æ¥
      cleanupRunning = false;
      return -1;
  }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ä»ä»¥ä¸Šçš„æºç åˆ†æå¯çŸ¥ï¼Œé¦–å…ˆä¼šå¯¹ç¼“å­˜ä¸­çš„è¿æ¥è¿›è¡Œéå†ï¼Œä»¥å¯»æ‰¾ä¸€ä¸ªé—²ç½®æ—¶é—´æœ€é•¿çš„è¿æ¥ï¼Œç„¶åæ ¹æ®è¯¥è¿æ¥çš„é—²ç½®æ—¶é•¿å’Œæœ€å¤§å…è®¸çš„è¿æ¥æ•°é‡ç­‰å‚æ•°æ¥å†³å®šæ˜¯å¦åº”è¯¥æ¸…ç†è¯¥è¿æ¥ã€‚åŒæ—¶æ³¨æ„ä¸Šé¢çš„æ–¹æ³•çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªæ—¶é—´ï¼Œå¦‚æœé—²ç½®æ—¶é—´æœ€é•¿çš„è¿æ¥ä»ç„¶éœ€è¦ä¸€æ®µæ—¶é—´æ‰èƒ½è¢«æ¸…ç†çš„æ—¶å€™ï¼Œä¼šè¿”å›è¿™æ®µæ—¶é—´çš„æ—¶é—´å·®ï¼Œç„¶åä¼šåœ¨è¿™æ®µæ—¶é—´ä¹‹åå†æ¬¡å¯¹è¿æ¥æ± è¿›è¡Œæ¸…ç†ã€‚</p>

<h3 id="å››æ€»ç»“">å››ã€æ€»ç»“</h3>

<p>ç»è¿‡ä¸Šé¢å¯¹OKHttpå†…éƒ¨å·¥ä½œæœºåˆ¶çš„ä¸€ç³»åˆ—åˆ†æï¼Œæˆ‘ç›¸ä¿¡ä½ å·²ç»å¯¹OKHttpå·²ç»æœ‰äº†ä¸€ä¸ªæ¯”è¾ƒæ·±å…¥çš„äº†è§£äº†ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬ä¼šåœ¨è¯·æ±‚çš„æ—¶å€™åˆå§‹åŒ–ä¸€ä¸ªCallçš„å®ä¾‹ï¼Œç„¶åæ‰§è¡Œå®ƒçš„execute()æ–¹æ³•æˆ–enqueue()æ–¹æ³•ï¼Œå†…éƒ¨æœ€åéƒ½ä¼šæ‰§è¡Œåˆ°getResponseWithInterceptorChain()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•é‡Œé¢é€šè¿‡æ‹¦æˆªå™¨ç»„æˆçš„è´£ä»»é“¾ï¼Œä¾æ¬¡ç»è¿‡ç”¨æˆ·è‡ªå®šä¹‰æ™®é€šæ‹¦æˆªå™¨ã€é‡è¯•æ‹¦æˆªå™¨ã€æ¡¥æ¥æ‹¦æˆªå™¨ã€ç¼“å­˜æ‹¦æˆªå™¨ã€è¿æ¥æ‹¦æˆªå™¨å’Œç”¨æˆ·è‡ªå®šä¹‰ç½‘ç»œæ‹¦æˆªå™¨ä»¥åŠè®¿é—®æœåŠ¡å™¨æ‹¦æˆªå™¨ç­‰æ‹¦æˆªå¤„ç†è¿‡ç¨‹ï¼Œæ¥è·å–åˆ°ä¸€ä¸ªå“åº”å¹¶äº¤ç»™ç”¨æˆ·ã€‚å…¶ä¸­ï¼Œé™¤äº†OKHttpçš„å†…éƒ¨è¯·æ±‚æµç¨‹è¿™ç‚¹ä¹‹å¤–ï¼Œç¼“å­˜å’Œè¿æ¥è¿™ä¸¤éƒ¨åˆ†å†…å®¹ä¹Ÿæ˜¯ä¸¤ä¸ªå¾ˆé‡è¦çš„ç‚¹ï¼Œç›¸ä¿¡ç»è¿‡æœ¬æ–‡çš„è®²è§£ï¼Œè¯»è€…å¯¹ç€ä¸‰éƒ¨åˆ†é‡ç‚¹å†…å®¹å·²ç»æœ‰äº†è‡ªå·±çš„ç†è§£ã€‚åé¢ï¼Œå°†ä¼šä¸ºå¤§å®¶å¸¦æ¥OKHttpçš„å°è£…æ¡†æ¶Retrofitæºç çš„æ·±å…¥åˆ†æï¼Œæ•¬è¯·æœŸå¾…~</p>
:ET